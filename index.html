<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bucled - AI Services</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f9f9f9; text-align: center; }
    header { padding: 40px; background: #1a1a1a; color: white; }
    h1 { margin: 0; font-size: 2.5em; }
    p { font-size: 1.2em; }
    .cta { margin: 30px; }
    button { padding: 12px 24px; background: #ff5e00; color: white; border: none; font-size: 1.1em; cursor: pointer; }
    button:hover { background: #e65100; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
  <header>
    <h1>Bucled</h1>
    <p>Next-level AI for your business.</p>
  </header>
  <div class="cta">
    <button onclick="alert('Contact us at hello@bucled.com!')">Learn More</button>
  </div>
  <script>
    // Neural network animation for AI landing page
    let particles = [];
    let connections = [];
    let nodeCount = 30;
    let maxDistance = 150;
    let mousePull = 100;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 1);
      
      // Create nodes
      for (let i = 0; i < nodeCount; i++) {
        particles.push({
          position: createVector(random(width), random(height)),
          velocity: createVector(random(-0.5, 0.5), random(-0.5, 0.5)),
          size: random(4, 12),
          color: color(random(180, 240), 80, 100),
          pulsePhase: random(TWO_PI)
        });
      }
    }

    function draw() {
      background(222, 30, 10);
      
      // Handle mouse interaction
      let mousePos = createVector(mouseX, mouseY);
      let mouseActive = mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height;
      
      // Update and draw connections first (behind nodes)
      updateConnections(mousePos, mouseActive);
      
      // Update and draw nodes
      for (let i = 0; i < particles.length; i++) {
        let p = particles[i];
        
        // Apply mouse attraction/repulsion
        if (mouseActive) {
          let force = p5.Vector.sub(mousePos, p.position);
          let distance = force.mag();
          if (distance < mousePull) {
            force.setMag(0.2);
            // Pull if mouse is pressed, otherwise push
            if (mouseIsPressed) {
              p.velocity.add(force);
            } else {
              p.velocity.sub(force);
            }
          }
        }
        
        // Update position
        p.position.add(p.velocity);
        
        // Boundary check with bounce
        if (p.position.x < 0 || p.position.x > width) {
          p.velocity.x *= -1;
          p.position.x = constrain(p.position.x, 0, width);
        }
        if (p.position.y < 0 || p.position.y > height) {
          p.velocity.y *= -1;
          p.position.y = constrain(p.position.y, 0, height);
        }
        
        // Draw node with pulsing effect
        let pulse = sin(frameCount * 0.05 + p.pulsePhase) * 0.5 + 0.5;
        let size = p.size * (0.8 + pulse * 0.4);
        
        // Glow effect
        noStroke();
        for (let j = 0; j < 4; j++) {
          let alpha = map(j, 0, 3, 0.1, 0);
          fill(hue(p.color), saturation(p.color), brightness(p.color), alpha);
          ellipse(p.position.x, p.position.y, size + j*8);
        }
        
        // Main node
        fill(p.color);
        ellipse(p.position.x, p.position.y, size);
      }
      
      // Add text overlay
      drawTextOverlay();
    }
    
    function updateConnections(mousePos, mouseActive) {
      // Create connections between particles
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          let p1 = particles[i];
          let p2 = particles[j];
          let d = p5.Vector.dist(p1.position, p2.position);
          
          if (d < maxDistance) {
            // Adjust opacity based on distance
            let alpha = map(d, 0, maxDistance, 0.8, 0);
            stroke(220, 70, 100, alpha);
            
            // Adjust stroke weight based on distance
            let sw = map(d, 0, maxDistance, 2, 0.5);
            strokeWeight(sw);
            
            // Draw connection line
            line(p1.position.x, p1.position.y, p2.position.x, p2.position.y);
            
            // Data packet animation along connections
            if (random() < 0.02) {
              connections.push({
                start: p1.position.copy(),
                end: p2.position.copy(),
                position: 0,
                speed: random(0.02, 0.08),
                color: color(random(180, 240), 80, 100)
              });
            }
          }
        }
      }
      
      // Update and draw data packets
      for (let i = connections.length - 1; i >= 0; i--) {
        let c = connections[i];
        c.position += c.speed;
        
        if (c.position > 1) {
          connections.splice(i, 1);
        } else {
          let x = lerp(c.start.x, c.end.x, c.position);
          let y = lerp(c.start.y, c.end.y, c.position);
          
          noStroke();
          fill(c.color);
          ellipse(x, y, 6);
        }
      }
    }
    
    function drawTextOverlay() {
      // Title text
      textAlign(CENTER, CENTER);
      textSize(width > 800 ? 60 : 40);
      fill(210, 10, 100, 0.9);
      textStyle(BOLD);
      text("NEXT-GEN AI", width/2, height/3);
      
      // Subtitle
      textSize(width > 800 ? 24 : 18);
      fill(210, 10, 90, 0.7);
      textStyle(NORMAL);
      text("Powering the future of intelligent solutions", width/2, height/3 + (width > 800 ? 70 : 50));
      
      // Instructions
      textSize(16);
      fill(210, 10, 80, 0.5);
      text("Click and drag to interact with the network", width/2, height - 50);
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
